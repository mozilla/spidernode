!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AddPtr	InlineMap.h	/^        AddPtr() {}$/;"	f	class:js::InlineMap::AddPtr	access:public	signature:()
AddPtr	InlineMap.h	/^        AddPtr(InlineElem *ptr, bool found)$/;"	f	class:js::InlineMap::AddPtr	access:private	signature:(InlineElem *ptr, bool found)
AddPtr	InlineMap.h	/^        explicit AddPtr(const WordMapAddPtr &p) : mapAddPtr(p), isInlinePtr(false) {}$/;"	f	class:js::InlineMap::AddPtr	access:private	signature:(const WordMapAddPtr &p)
AddPtr	InlineMap.h	/^    class AddPtr$/;"	c	class:js::InlineMap	access:public
AlignPtr	LifoAlloc.h	/^AlignPtr(void *orig)$/;"	f	namespace:js::detail	signature:(void *orig)
BitArray	BitArray.h	/^class BitArray$/;"	c	namespace:js
BumpChunk	LifoAlloc.h	/^    explicit BumpChunk(size_t bumpSpaceSize)$/;"	f	class:js::detail::BumpChunk	access:private	signature:(size_t bumpSpaceSize)
BumpChunk	LifoAlloc.h	/^    typedef detail::BumpChunk BumpChunk;$/;"	t	class:js::LifoAlloc	access:private
BumpChunk	LifoAlloc.h	/^class BumpChunk$/;"	c	namespace:js::detail
ConvertibleToBool	InlineMap.h	/^        typedef AddPtr ******* ConvertibleToBool;$/;"	t	class:js::InlineMap::AddPtr	access:private
ConvertibleToBool	InlineMap.h	/^        typedef Ptr ******* ConvertibleToBool;$/;"	t	class:js::InlineMap::Ptr	access:private
CopyNonEmptyArray	Sort.h	/^CopyNonEmptyArray(T *dst, const T *src, size_t nelems)$/;"	f	namespace:js::detail	signature:(T *dst, const T *src, size_t nelems)
CrashAtUnhandlableOOM	LifoAlloc.h	/^CrashAtUnhandlableOOM(const char *reason);$/;"	p	namespace:js	signature:(const char *reason)
Entry	InlineMap.h	/^        Entry(const K &key, V &value) : key_(key), value_(value) {}$/;"	f	class:js::InlineMap::Entry	access:private	signature:(const K &key, V &value)
Entry	InlineMap.h	/^    class Entry$/;"	c	class:js::InlineMap	access:public
Enum	LifoAlloc.h	/^        explicit Enum(LifoAlloc &alloc)$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:(LifoAlloc &alloc)
Enum	LifoAlloc.h	/^    class Enum$/;"	c	class:js::LifoAlloc	access:public
Fallibility	LifoAlloc.h	/^enum Fallibility {$/;"	g	namespace:js
Fallible	LifoAlloc.h	/^    Fallible,$/;"	e	enum:js::Fallibility
FixedSizeHashSet	FixedSizeHash.h	/^    FixedSizeHashSet()$/;"	f	class:js::FixedSizeHashSet	access:public	signature:()
FixedSizeHashSet	FixedSizeHash.h	/^class FixedSizeHashSet$/;"	c	namespace:js
HUGE_ALLOCATION	LifoAlloc.h	/^    static const unsigned HUGE_ALLOCATION = 50 * 1024 * 1024;$/;"	m	class:js::LifoAlloc	access:public
IdValuePair	IdValuePair.h	/^    IdValuePair() {}$/;"	f	struct:js::IdValuePair	access:public	signature:()
IdValuePair	IdValuePair.h	/^    explicit IdValuePair(jsid idArg)$/;"	f	struct:js::IdValuePair	access:public	signature:(jsid idArg)
IdValuePair	IdValuePair.h	/^struct IdValuePair$/;"	s	namespace:js
Infallible	LifoAlloc.h	/^    Infallible$/;"	e	enum:js::Fallibility
InlineElem	InlineMap.h	/^    struct InlineElem$/;"	s	class:js::InlineMap	access:public
InlineMap	InlineMap.h	/^    explicit InlineMap() : inlNext(0), inlCount(0) { }$/;"	f	class:js::InlineMap	access:public	signature:()
InlineMap	InlineMap.h	/^class InlineMap$/;"	c	namespace:js
LIFO_ALLOC_ALIGN	LifoAlloc.h	/^static const size_t LIFO_ALLOC_ALIGN = 8;$/;"	m	namespace:js::detail
LifoAlloc	LifoAlloc.h	/^    explicit LifoAlloc(size_t defaultChunkSize)$/;"	f	class:js::LifoAlloc	access:public	signature:(size_t defaultChunkSize)
LifoAlloc	LifoAlloc.h	/^class LifoAlloc$/;"	c	namespace:js
LifoAlloc::freeAll	LifoAlloc.cpp	/^LifoAlloc::freeAll()$/;"	f	class:LifoAlloc	signature:()
LifoAlloc::getOrCreateChunk	LifoAlloc.cpp	/^LifoAlloc::getOrCreateChunk(size_t n)$/;"	f	class:LifoAlloc	signature:(size_t n)
LifoAlloc::transferFrom	LifoAlloc.cpp	/^LifoAlloc::transferFrom(LifoAlloc *other)$/;"	f	class:LifoAlloc	signature:(LifoAlloc *other)
LifoAlloc::transferUnusedFrom	LifoAlloc.cpp	/^LifoAlloc::transferUnusedFrom(LifoAlloc *other)$/;"	f	class:LifoAlloc	signature:(LifoAlloc *other)
LifoAllocPolicy	LifoAlloc.h	/^    MOZ_IMPLICIT LifoAllocPolicy(LifoAlloc &alloc)$/;"	f	class:js::LifoAllocPolicy	access:public	signature:(LifoAlloc &alloc)
LifoAllocPolicy	LifoAlloc.h	/^class LifoAllocPolicy$/;"	c	namespace:js
LifoAllocScope	LifoAlloc.h	/^    explicit LifoAllocScope(LifoAlloc *lifoAlloc$/;"	f	class:js::LifoAllocScope	access:public	signature:(LifoAlloc *lifoAlloc MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
LifoAllocScope	LifoAlloc.h	/^class LifoAllocScope$/;"	c	namespace:js
Lookup	FixedSizeHash.h	/^    typedef typename HashPolicy::Lookup Lookup;$/;"	t	class:js::FixedSizeHashSet	access:public
MOZ_DELETE	LifoAlloc.h	/^    LifoAlloc(const LifoAlloc &) MOZ_DELETE;$/;"	m	class:js::LifoAlloc	access:private
MOZ_DELETE	LifoAlloc.h	/^    void operator=(const LifoAlloc &) MOZ_DELETE;$/;"	m	class:js::LifoAlloc	access:private
MOZ_DELETE	PriorityQueue.h	/^    PriorityQueue &operator=(const PriorityQueue &) MOZ_DELETE;$/;"	m	class:js::PriorityQueue	access:private
MOZ_DELETE	PriorityQueue.h	/^    PriorityQueue(const PriorityQueue &) MOZ_DELETE;$/;"	m	class:js::PriorityQueue	access:private
MOZ_DELETE	SplayTree.h	/^    SplayTree &operator=(const SplayTree &) MOZ_DELETE;$/;"	m	class:js::SplayTree	access:private
MOZ_DELETE	SplayTree.h	/^    SplayTree(const SplayTree &) MOZ_DELETE;$/;"	m	class:js::SplayTree	access:private
Mark	LifoAlloc.h	/^        Mark() : chunk(nullptr), markInChunk(nullptr) {}$/;"	f	class:js::LifoAlloc::Mark	access:public	signature:()
Mark	LifoAlloc.h	/^        Mark(BumpChunk *chunk, void *markInChunk) : chunk(chunk), markInChunk(markInChunk) {}$/;"	f	class:js::LifoAlloc::Mark	access:private	signature:(BumpChunk *chunk, void *markInChunk)
Mark	LifoAlloc.h	/^    class Mark {$/;"	c	class:js::LifoAlloc	access:public
MergeArrayRuns	Sort.h	/^MergeArrayRuns(T *dst, const T *src, size_t run1, size_t run2, Comparator c)$/;"	f	namespace:js::detail	signature:(T *dst, const T *src, size_t run1, size_t run2, Comparator c)
MergeSort	Sort.h	/^MergeSort(T *array, size_t nelems, T *scratch, Comparator c)$/;"	f	namespace:js	signature:(T *array, size_t nelems, T *scratch, Comparator c)
Node	SplayTree.h	/^        explicit Node(const T &item)$/;"	f	struct:js::SplayTree::Node	access:public	signature:(const T &item)
Node	SplayTree.h	/^    struct Node {$/;"	s	class:js::SplayTree	access:private
NumHashes	FixedSizeHash.h	/^    static const size_t NumHashes = HashPolicy::NumHashes;$/;"	m	class:js::FixedSizeHashSet	access:private
PriorityQueue	PriorityQueue.h	/^    explicit PriorityQueue(AllocPolicy ap = AllocPolicy())$/;"	f	class:js::PriorityQueue	access:public	signature:(AllocPolicy ap = AllocPolicy())
PriorityQueue	PriorityQueue.h	/^class PriorityQueue$/;"	c	namespace:js
Ptr	InlineMap.h	/^        Ptr() {$/;"	f	class:js::InlineMap::Ptr	access:public	signature:()
Ptr	InlineMap.h	/^        explicit Ptr(InlineElem *ie) : inlPtr(ie), isInlinePtr(true) {}$/;"	f	class:js::InlineMap::Ptr	access:private	signature:(InlineElem *ie)
Ptr	InlineMap.h	/^        explicit Ptr(WordMapPtr p) : mapPtr(p), isInlinePtr(false) {}$/;"	f	class:js::InlineMap::Ptr	access:private	signature:(WordMapPtr p)
Ptr	InlineMap.h	/^    class Ptr$/;"	c	class:js::InlineMap	access:public
Range	InlineMap.h	/^        Range(const InlineElem *begin, const InlineElem *end_)$/;"	f	class:js::InlineMap::Range	access:private	signature:(const InlineElem *begin, const InlineElem *end_)
Range	InlineMap.h	/^        explicit Range(WordMapRange r)$/;"	f	class:js::InlineMap::Range	access:private	signature:(WordMapRange r)
Range	InlineMap.h	/^    class Range$/;"	c	class:js::InlineMap	access:public
SplayTree	SplayTree.h	/^    explicit SplayTree(LifoAlloc *alloc = nullptr)$/;"	f	class:js::SplayTree	access:public	signature:(LifoAlloc *alloc = nullptr)
SplayTree	SplayTree.h	/^class SplayTree$/;"	c	namespace:js
WordMap	InlineMap.h	/^    typedef HashMap<K, V, DefaultHasher<K>, SystemAllocPolicy> WordMap;$/;"	t	class:js::InlineMap	access:public
WordMapAddPtr	InlineMap.h	/^    typedef typename WordMap::AddPtr    WordMapAddPtr;$/;"	t	class:js::InlineMap	access:private
WordMapPtr	InlineMap.h	/^    typedef typename WordMap::Ptr       WordMapPtr;$/;"	t	class:js::InlineMap	access:private
WordMapRange	InlineMap.h	/^    typedef typename WordMap::Range     WordMapRange;$/;"	t	class:js::InlineMap	access:private
ZeroIsReserved	InlineMap.h	/^template <typename T> struct ZeroIsReserved         { static const bool result = false; };$/;"	s	namespace:js
ZeroIsReserved	InlineMap.h	/^template <typename T> struct ZeroIsReserved<T *>    { static const bool result = true; };$/;"	s	namespace:js
add	InlineMap.h	/^    bool add(AddPtr &p, const K &key, const V &value) {$/;"	f	class:js::InlineMap	access:public	signature:(AddPtr &p, const K &key, const V &value)
advancePastNulls	InlineMap.h	/^        void advancePastNulls(InlineElem *begin) {$/;"	f	class:js::InlineMap::Range	access:private	signature:(InlineElem *begin)
all	InlineMap.h	/^    Range all() const {$/;"	f	class:js::InlineMap	access:public	signature:() const
alloc	LifoAlloc.h	/^    LifoAlloc &alloc() {$/;"	f	class:js::LifoAllocScope	access:public	signature:()
alloc	LifoAlloc.h	/^    void *alloc(size_t n) {$/;"	f	class:js::LifoAlloc	access:public	signature:(size_t n)
alloc	SplayTree.h	/^    LifoAlloc *alloc;$/;"	m	class:js::SplayTree	access:private
allocInfallible	LifoAlloc.h	/^    void *allocInfallible(size_t n) {$/;"	f	class:js::LifoAlloc	access:public	signature:(size_t n)
alloc_	LifoAlloc.h	/^        LifoAlloc *alloc_;  \/\/ The LifoAlloc being traversed.$/;"	m	class:js::LifoAlloc::Enum	access:private
alloc_	LifoAlloc.h	/^    LifoAlloc &alloc_;$/;"	m	class:js::LifoAllocPolicy	access:private
allocateNode	SplayTree.h	/^    Node *allocateNode(const T &v)$/;"	f	class:js::SplayTree	access:private	signature:(const T &v)
appendUnused	LifoAlloc.h	/^    void appendUnused(BumpChunk *start, BumpChunk *end) {$/;"	f	class:js::LifoAlloc	access:private	signature:(BumpChunk *start, BumpChunk *end)
appendUsed	LifoAlloc.h	/^    void appendUsed(BumpChunk *start, BumpChunk *latest, BumpChunk *end) {$/;"	f	class:js::LifoAlloc	access:private	signature:(BumpChunk *start, BumpChunk *latest, BumpChunk *end)
asInline	InlineMap.h	/^    const InlineElem *asInline() const {$/;"	f	class:js::InlineMap	access:public	signature:() const
asMap	InlineMap.h	/^    const WordMap &asMap() const {$/;"	f	class:js::InlineMap	access:public	signature:() const
availableInCurrentChunk	LifoAlloc.h	/^    size_t availableInCurrentChunk() const {$/;"	f	class:js::LifoAlloc	access:public	signature:() const
bitsPerElement	BitArray.h	/^    static const size_t bitsPerElement = sizeof(uintptr_t) * CHAR_BIT;$/;"	m	class:js::BitArray	access:private
bump	LifoAlloc.h	/^    char        *bump;          \/\/ start of the available data$/;"	m	class:js::detail::BumpChunk	access:private
bumpBase	LifoAlloc.h	/^    char *bumpBase() const { return limit - bumpSpaceSize; }$/;"	f	class:js::detail::BumpChunk	access:private	signature:() const
bumpCurPtr	InlineMap.h	/^        void bumpCurPtr() {$/;"	f	class:js::InlineMap::Range	access:private	signature:()
bumpSpaceSize	LifoAlloc.h	/^    size_t      bumpSpaceSize;  \/\/ size of the data area$/;"	m	class:js::detail::BumpChunk	access:private
canAlloc	LifoAlloc.cpp	/^BumpChunk::canAlloc(size_t n)$/;"	f	class:js::detail::BumpChunk	signature:(size_t n)
canAlloc	LifoAlloc.h	/^    bool canAlloc(size_t n);$/;"	p	class:js::detail::BumpChunk	access:public	signature:(size_t n)
checkCoherency	SplayTree.h	/^    Node *checkCoherency(Node *node, Node *minimum)$/;"	f	class:js::SplayTree	access:private	signature:(Node *node, Node *minimum)
checkInlineRangeInvariants	InlineMap.h	/^        bool checkInlineRangeInvariants() const {$/;"	f	class:js::InlineMap::Range	access:private	signature:() const
chunk	LifoAlloc.h	/^        BumpChunk *chunk;$/;"	m	class:js::LifoAlloc::Mark	access:private
chunk_	LifoAlloc.h	/^        BumpChunk *chunk_;  \/\/ The current chunk.$/;"	m	class:js::LifoAlloc::Enum	access:private
clear	InlineMap.h	/^    void clear() {$/;"	f	class:js::InlineMap	access:public	signature:()
computedSizeOfExcludingThis	LifoAlloc.h	/^    size_t computedSizeOfExcludingThis() const {$/;"	f	class:js::LifoAlloc	access:public	signature:() const
computedSizeOfIncludingThis	LifoAlloc.h	/^    size_t computedSizeOfIncludingThis() {$/;"	f	class:js::detail::BumpChunk	access:public	signature:()
contains	LifoAlloc.h	/^    bool contains(void *mark) const {$/;"	f	class:js::detail::BumpChunk	access:public	signature:(void *mark) const
contains	SplayTree.h	/^    bool contains(const T &v, T *res)$/;"	f	class:js::SplayTree	access:public	signature:(const T &v, T *res)
count	InlineMap.h	/^    size_t count() {$/;"	f	class:js::InlineMap	access:public	signature:()
cur	InlineMap.h	/^        InlineElem      *cur;$/;"	m	class:js::InlineMap::Range	access:private
curSize_	LifoAlloc.h	/^    size_t      curSize_;$/;"	m	class:js::LifoAlloc	access:private
decrementCurSize	LifoAlloc.h	/^    void decrementCurSize(size_t size) {$/;"	f	class:js::LifoAlloc	access:private	signature:(size_t size)
defaultChunkSize	LifoAlloc.h	/^    size_t defaultChunkSize() const { return defaultChunkSize_; }$/;"	f	class:js::LifoAlloc	access:public	signature:() const
defaultChunkSize_	LifoAlloc.h	/^    size_t      defaultChunkSize_;$/;"	m	class:js::LifoAlloc	access:private
delete_	LifoAlloc.cpp	/^BumpChunk::delete_(BumpChunk *chunk)$/;"	f	class:js::detail::BumpChunk	signature:(BumpChunk *chunk)
delete_	LifoAlloc.h	/^    static void delete_(BumpChunk *chunk);$/;"	p	class:js::detail::BumpChunk	access:public	signature:(BumpChunk *chunk)
detail	LifoAlloc.cpp	/^namespace detail {$/;"	n	namespace:js	file:
detail	LifoAlloc.h	/^namespace detail {$/;"	n	namespace:js
detail	Sort.h	/^namespace detail {$/;"	n	namespace:js
disableCheckCoherency	SplayTree.h	/^    void disableCheckCoherency() {$/;"	f	class:js::SplayTree	access:public	signature:()
ds_BitArray_h	BitArray.h	/^#define ds_BitArray_h$/;"	d
ds_IdValuePair_h	IdValuePair.h	/^#define ds_IdValuePair_h$/;"	d
ds_InlineMap_h	InlineMap.h	/^#define ds_InlineMap_h$/;"	d
ds_LifoAlloc_h	LifoAlloc.h	/^#define ds_LifoAlloc_h$/;"	d
ds_PriorityQueue_h	PriorityQueue.h	/^#define ds_PriorityQueue_h$/;"	d
ds_Sort_h	Sort.h	/^#define ds_Sort_h$/;"	d
ds_SplayTree_h	SplayTree.h	/^#define ds_SplayTree_h$/;"	d
empty	InlineMap.h	/^        bool empty() const {$/;"	f	class:js::InlineMap::Range	access:public	signature:() const
empty	InlineMap.h	/^    bool empty() const {$/;"	f	class:js::InlineMap	access:public	signature:() const
empty	LifoAlloc.h	/^        bool empty() {$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:()
empty	PriorityQueue.h	/^    bool empty() const {$/;"	f	class:js::PriorityQueue	access:public	signature:() const
empty	SplayTree.h	/^    bool empty() const {$/;"	f	class:js::SplayTree	access:public	signature:() const
enableCheckCoherency	SplayTree.h	/^    bool enableCheckCoherency;$/;"	m	class:js::SplayTree	access:private
end	InlineMap.h	/^        InlineElem      *end;$/;"	m	class:js::InlineMap::Range	access:private
end	LifoAlloc.h	/^    void *end() const { return limit; }$/;"	f	class:js::detail::BumpChunk	access:public	signature:() const
ensureSpaceAndAlignment	LifoAlloc.h	/^        void ensureSpaceAndAlignment(size_t size) {$/;"	f	class:js::LifoAlloc::Enum	access:private	signature:(size_t size)
ensureUnusedApproximate	LifoAlloc.h	/^    bool ensureUnusedApproximate(size_t n) {$/;"	f	class:js::LifoAlloc	access:public	signature:(size_t n)
entries	FixedSizeHash.h	/^    T entries[Capacity];$/;"	m	class:js::FixedSizeHashSet	access:private
first	LifoAlloc.h	/^    BumpChunk   *first;$/;"	m	class:js::LifoAlloc	access:private
forEach	SplayTree.h	/^    void forEach(Op op)$/;"	f	class:js::SplayTree	access:public	signature:(Op op)
forEachInner	SplayTree.h	/^    void forEachInner(Op op, Node *node)$/;"	f	class:js::SplayTree	access:private	signature:(Op op, Node *node)
found	InlineMap.h	/^        bool found() const {$/;"	f	class:js::InlineMap::AddPtr	access:public	signature:() const
found	InlineMap.h	/^        bool found() const {$/;"	f	class:js::InlineMap::Ptr	access:public	signature:() const
freeAll	LifoAlloc.cpp	/^LifoAlloc::freeAll()$/;"	f	class:LifoAlloc	signature:()
freeAll	LifoAlloc.h	/^    void freeAll();$/;"	p	class:js::LifoAlloc	access:public	signature:()
freeAllIfHugeAndUnused	LifoAlloc.h	/^    void freeAllIfHugeAndUnused() {$/;"	f	class:js::LifoAlloc	access:public	signature:()
freeList	SplayTree.h	/^    Node *root, *freeList;$/;"	m	class:js::SplayTree	access:private
freeNode	SplayTree.h	/^    void freeNode(Node *node)$/;"	f	class:js::SplayTree	access:private	signature:(Node *node)
free_	LifoAlloc.h	/^    void free_(void *p) {$/;"	f	class:js::LifoAllocPolicy	access:public	signature:(void *p)
front	InlineMap.h	/^        Entry front() {$/;"	f	class:js::InlineMap::Range	access:public	signature:()
get	LifoAlloc.h	/^        T *get(size_t size = sizeof(T)) {$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:(size_t size = sizeof(T))
getBuckets	FixedSizeHash.h	/^    void getBuckets(const S &s, size_t buckets[NumHashes])$/;"	f	class:js::FixedSizeHashSet	access:private	signature:(const S &s, size_t buckets[NumHashes])
getOrCreateChunk	LifoAlloc.cpp	/^LifoAlloc::getOrCreateChunk(size_t n)$/;"	f	class:LifoAlloc	signature:(size_t n)
getOrCreateChunk	LifoAlloc.h	/^    BumpChunk *getOrCreateChunk(size_t n);$/;"	p	class:js::LifoAlloc	access:private	signature:(size_t n)
headerBase	LifoAlloc.h	/^    char *headerBase() { return reinterpret_cast<char *>(this); }$/;"	f	class:js::detail::BumpChunk	access:private	signature:()
heap	PriorityQueue.h	/^    Vector<T, MinInlineCapacity, AllocPolicy> heap;$/;"	m	class:js::PriorityQueue	access:private
id	IdValuePair.h	/^    jsid id;$/;"	m	struct:js::IdValuePair	access:public
incrementCurSize	LifoAlloc.h	/^    void incrementCurSize(size_t size) {$/;"	f	class:js::LifoAlloc	access:private	signature:(size_t size)
infallibleInsert	PriorityQueue.h	/^    void infallibleInsert(const T &v) {$/;"	f	class:js::PriorityQueue	access:public	signature:(const T &v)
inl	InlineMap.h	/^    InlineElem      inl[InlineElems];$/;"	m	class:js::InlineMap	access:private
inlAddPtr	InlineMap.h	/^        InlineElem      *inlAddPtr;$/;"	m	class:js::InlineMap::AddPtr	access:private
inlCount	InlineMap.h	/^    size_t          inlCount;$/;"	m	class:js::InlineMap	access:private
inlNext	InlineMap.h	/^    size_t          inlNext;$/;"	m	class:js::InlineMap	access:private
inlPtr	InlineMap.h	/^        InlineElem  *inlPtr;$/;"	m	class:js::InlineMap::Ptr	access:private
inlPtrFound	InlineMap.h	/^        bool            inlPtrFound;$/;"	m	class:js::InlineMap::AddPtr	access:private
inlineEnd	InlineMap.h	/^    const InlineElem *inlineEnd() const {$/;"	f	class:js::InlineMap	access:public	signature:() const
insert	FixedSizeHash.h	/^    void insert(const Lookup &lookup, const T &entry)$/;"	f	class:js::FixedSizeHashSet	access:public	signature:(const Lookup &lookup, const T &entry)
insert	PriorityQueue.h	/^    bool insert(const T &v) {$/;"	f	class:js::PriorityQueue	access:public	signature:(const T &v)
insert	SplayTree.h	/^    bool insert(const T &v)$/;"	f	class:js::SplayTree	access:public	signature:(const T &v)
isEmpty	LifoAlloc.h	/^    bool isEmpty() const {$/;"	f	class:js::LifoAlloc	access:public	signature:() const
isInline	InlineMap.h	/^        bool            isInline;$/;"	m	class:js::InlineMap::Range	access:private
isInlinePtr	InlineMap.h	/^        bool            isInlinePtr;$/;"	m	class:js::InlineMap::AddPtr	access:private
isInlinePtr	InlineMap.h	/^        bool        isInlinePtr;$/;"	m	class:js::InlineMap::Ptr	access:private
isInlineRange	InlineMap.h	/^        bool isInlineRange() const {$/;"	f	class:js::InlineMap::Range	access:private	signature:() const
isMap	InlineMap.h	/^    bool isMap() const {$/;"	f	class:js::InlineMap	access:public	signature:() const
item	SplayTree.h	/^        T item;$/;"	m	struct:js::SplayTree::Node	access:public
js	BitArray.h	/^namespace js {$/;"	n
js	FixedSizeHash.h	/^namespace js {$/;"	n
js	IdValuePair.h	/^namespace js {$/;"	n
js	InlineMap.h	/^namespace js {$/;"	n
js	LifoAlloc.cpp	/^namespace js {$/;"	n	file:
js	LifoAlloc.h	/^namespace js {$/;"	n
js	PriorityQueue.h	/^namespace js {$/;"	n
js	Sort.h	/^namespace js {$/;"	n
js	SplayTree.h	/^namespace js {$/;"	n
js::BitArray	BitArray.h	/^class BitArray$/;"	c	namespace:js
js::BitArray::bitsPerElement	BitArray.h	/^    static const size_t bitsPerElement = sizeof(uintptr_t) * CHAR_BIT;$/;"	m	class:js::BitArray	access:private
js::BitArray::numSlots	BitArray.h	/^    static const size_t numSlots = nbits \/ bitsPerElement + (nbits % bitsPerElement == 0 ? 0 : 1);$/;"	m	class:js::BitArray	access:private
js::BitArray::paddingBits	BitArray.h	/^    static const size_t paddingBits = (numSlots * bitsPerElement) - nbits;$/;"	m	class:js::BitArray	access:private
js::CrashAtUnhandlableOOM	LifoAlloc.h	/^CrashAtUnhandlableOOM(const char *reason);$/;"	p	namespace:js	signature:(const char *reason)
js::Fallibility	LifoAlloc.h	/^enum Fallibility {$/;"	g	namespace:js
js::Fallible	LifoAlloc.h	/^    Fallible,$/;"	e	enum:js::Fallibility
js::FixedSizeHashSet	FixedSizeHash.h	/^class FixedSizeHashSet$/;"	c	namespace:js
js::FixedSizeHashSet::FixedSizeHashSet	FixedSizeHash.h	/^    FixedSizeHashSet()$/;"	f	class:js::FixedSizeHashSet	access:public	signature:()
js::FixedSizeHashSet::Lookup	FixedSizeHash.h	/^    typedef typename HashPolicy::Lookup Lookup;$/;"	t	class:js::FixedSizeHashSet	access:public
js::FixedSizeHashSet::NumHashes	FixedSizeHash.h	/^    static const size_t NumHashes = HashPolicy::NumHashes;$/;"	m	class:js::FixedSizeHashSet	access:private
js::FixedSizeHashSet::entries	FixedSizeHash.h	/^    T entries[Capacity];$/;"	m	class:js::FixedSizeHashSet	access:private
js::FixedSizeHashSet::getBuckets	FixedSizeHash.h	/^    void getBuckets(const S &s, size_t buckets[NumHashes])$/;"	f	class:js::FixedSizeHashSet	access:private	signature:(const S &s, size_t buckets[NumHashes])
js::FixedSizeHashSet::insert	FixedSizeHash.h	/^    void insert(const Lookup &lookup, const T &entry)$/;"	f	class:js::FixedSizeHashSet	access:public	signature:(const Lookup &lookup, const T &entry)
js::FixedSizeHashSet::lastOperations	FixedSizeHash.h	/^    uint32_t lastOperations[Capacity];$/;"	m	class:js::FixedSizeHashSet	access:private
js::FixedSizeHashSet::lookup	FixedSizeHash.h	/^    bool lookup(const Lookup &lookup, T *pentry)$/;"	f	class:js::FixedSizeHashSet	access:public	signature:(const Lookup &lookup, T *pentry)
js::FixedSizeHashSet::lookupReference	FixedSizeHash.h	/^    bool lookupReference(const S &s, size_t *pbucket)$/;"	f	class:js::FixedSizeHashSet	access:private	signature:(const S &s, size_t *pbucket)
js::FixedSizeHashSet::numOperations	FixedSizeHash.h	/^    uint32_t numOperations;$/;"	m	class:js::FixedSizeHashSet	access:private
js::FixedSizeHashSet::remove	FixedSizeHash.h	/^    void remove(const S &s)$/;"	f	class:js::FixedSizeHashSet	access:public	signature:(const S &s)
js::IdValuePair	IdValuePair.h	/^struct IdValuePair$/;"	s	namespace:js
js::IdValuePair::IdValuePair	IdValuePair.h	/^    IdValuePair() {}$/;"	f	struct:js::IdValuePair	access:public	signature:()
js::IdValuePair::IdValuePair	IdValuePair.h	/^    explicit IdValuePair(jsid idArg)$/;"	f	struct:js::IdValuePair	access:public	signature:(jsid idArg)
js::IdValuePair::id	IdValuePair.h	/^    jsid id;$/;"	m	struct:js::IdValuePair	access:public
js::IdValuePair::value	IdValuePair.h	/^    Value value;$/;"	m	struct:js::IdValuePair	access:public
js::Infallible	LifoAlloc.h	/^    Infallible$/;"	e	enum:js::Fallibility
js::InlineMap	InlineMap.h	/^class InlineMap$/;"	c	namespace:js
js::InlineMap::AddPtr	InlineMap.h	/^    class AddPtr$/;"	c	class:js::InlineMap	access:public
js::InlineMap::AddPtr::AddPtr	InlineMap.h	/^        AddPtr() {}$/;"	f	class:js::InlineMap::AddPtr	access:public	signature:()
js::InlineMap::AddPtr::AddPtr	InlineMap.h	/^        AddPtr(InlineElem *ptr, bool found)$/;"	f	class:js::InlineMap::AddPtr	access:private	signature:(InlineElem *ptr, bool found)
js::InlineMap::AddPtr::AddPtr	InlineMap.h	/^        explicit AddPtr(const WordMapAddPtr &p) : mapAddPtr(p), isInlinePtr(false) {}$/;"	f	class:js::InlineMap::AddPtr	access:private	signature:(const WordMapAddPtr &p)
js::InlineMap::AddPtr::ConvertibleToBool	InlineMap.h	/^        typedef AddPtr ******* ConvertibleToBool;$/;"	t	class:js::InlineMap::AddPtr	access:private
js::InlineMap::AddPtr::found	InlineMap.h	/^        bool found() const {$/;"	f	class:js::InlineMap::AddPtr	access:public	signature:() const
js::InlineMap::AddPtr::inlAddPtr	InlineMap.h	/^        InlineElem      *inlAddPtr;$/;"	m	class:js::InlineMap::AddPtr	access:private
js::InlineMap::AddPtr::inlPtrFound	InlineMap.h	/^        bool            inlPtrFound;$/;"	m	class:js::InlineMap::AddPtr	access:private
js::InlineMap::AddPtr::isInlinePtr	InlineMap.h	/^        bool            isInlinePtr;$/;"	m	class:js::InlineMap::AddPtr	access:private
js::InlineMap::AddPtr::mapAddPtr	InlineMap.h	/^        WordMapAddPtr   mapAddPtr;$/;"	m	class:js::InlineMap::AddPtr	access:private
js::InlineMap::AddPtr::operator ==	InlineMap.h	/^        void operator==(const AddPtr &other);$/;"	p	class:js::InlineMap::AddPtr	access:private	signature:(const AddPtr &other)
js::InlineMap::AddPtr::operator ConvertibleToBool	InlineMap.h	/^        operator ConvertibleToBool() const {$/;"	f	class:js::InlineMap::AddPtr	access:public	signature:() const
js::InlineMap::AddPtr::value	InlineMap.h	/^        V &value() {$/;"	f	class:js::InlineMap::AddPtr	access:public	signature:()
js::InlineMap::Entry	InlineMap.h	/^    class Entry$/;"	c	class:js::InlineMap	access:public
js::InlineMap::Entry::Entry	InlineMap.h	/^        Entry(const K &key, V &value) : key_(key), value_(value) {}$/;"	f	class:js::InlineMap::Entry	access:private	signature:(const K &key, V &value)
js::InlineMap::Entry::key	InlineMap.h	/^        const K &key() { return key_; }$/;"	f	class:js::InlineMap::Entry	access:public	signature:()
js::InlineMap::Entry::key_	InlineMap.h	/^        const K &key_;$/;"	m	class:js::InlineMap::Entry	access:private
js::InlineMap::Entry::value	InlineMap.h	/^        V &value() { return value_; }$/;"	f	class:js::InlineMap::Entry	access:public	signature:()
js::InlineMap::Entry::value_	InlineMap.h	/^        V &value_;$/;"	m	class:js::InlineMap::Entry	access:private
js::InlineMap::InlineElem	InlineMap.h	/^    struct InlineElem$/;"	s	class:js::InlineMap	access:public
js::InlineMap::InlineElem::key	InlineMap.h	/^        K key;$/;"	m	struct:js::InlineMap::InlineElem	access:public
js::InlineMap::InlineElem::value	InlineMap.h	/^        V value;$/;"	m	struct:js::InlineMap::InlineElem	access:public
js::InlineMap::InlineMap	InlineMap.h	/^    explicit InlineMap() : inlNext(0), inlCount(0) { }$/;"	f	class:js::InlineMap	access:public	signature:()
js::InlineMap::Ptr	InlineMap.h	/^    class Ptr$/;"	c	class:js::InlineMap	access:public
js::InlineMap::Ptr::ConvertibleToBool	InlineMap.h	/^        typedef Ptr ******* ConvertibleToBool;$/;"	t	class:js::InlineMap::Ptr	access:private
js::InlineMap::Ptr::Ptr	InlineMap.h	/^        Ptr() {$/;"	f	class:js::InlineMap::Ptr	access:public	signature:()
js::InlineMap::Ptr::Ptr	InlineMap.h	/^        explicit Ptr(InlineElem *ie) : inlPtr(ie), isInlinePtr(true) {}$/;"	f	class:js::InlineMap::Ptr	access:private	signature:(InlineElem *ie)
js::InlineMap::Ptr::Ptr	InlineMap.h	/^        explicit Ptr(WordMapPtr p) : mapPtr(p), isInlinePtr(false) {}$/;"	f	class:js::InlineMap::Ptr	access:private	signature:(WordMapPtr p)
js::InlineMap::Ptr::found	InlineMap.h	/^        bool found() const {$/;"	f	class:js::InlineMap::Ptr	access:public	signature:() const
js::InlineMap::Ptr::inlPtr	InlineMap.h	/^        InlineElem  *inlPtr;$/;"	m	class:js::InlineMap::Ptr	access:private
js::InlineMap::Ptr::isInlinePtr	InlineMap.h	/^        bool        isInlinePtr;$/;"	m	class:js::InlineMap::Ptr	access:private
js::InlineMap::Ptr::key	InlineMap.h	/^        K &key() {$/;"	f	class:js::InlineMap::Ptr	access:public	signature:()
js::InlineMap::Ptr::mapPtr	InlineMap.h	/^        WordMapPtr  mapPtr;$/;"	m	class:js::InlineMap::Ptr	access:private
js::InlineMap::Ptr::operator ==	InlineMap.h	/^        void operator==(const Ptr &other);$/;"	p	class:js::InlineMap::Ptr	access:private	signature:(const Ptr &other)
js::InlineMap::Ptr::operator ConvertibleToBool	InlineMap.h	/^        operator ConvertibleToBool() const {$/;"	f	class:js::InlineMap::Ptr	access:public	signature:() const
js::InlineMap::Ptr::value	InlineMap.h	/^        V &value() {$/;"	f	class:js::InlineMap::Ptr	access:public	signature:()
js::InlineMap::Range	InlineMap.h	/^    class Range$/;"	c	class:js::InlineMap	access:public
js::InlineMap::Range::Range	InlineMap.h	/^        Range(const InlineElem *begin, const InlineElem *end_)$/;"	f	class:js::InlineMap::Range	access:private	signature:(const InlineElem *begin, const InlineElem *end_)
js::InlineMap::Range::Range	InlineMap.h	/^        explicit Range(WordMapRange r)$/;"	f	class:js::InlineMap::Range	access:private	signature:(WordMapRange r)
js::InlineMap::Range::advancePastNulls	InlineMap.h	/^        void advancePastNulls(InlineElem *begin) {$/;"	f	class:js::InlineMap::Range	access:private	signature:(InlineElem *begin)
js::InlineMap::Range::bumpCurPtr	InlineMap.h	/^        void bumpCurPtr() {$/;"	f	class:js::InlineMap::Range	access:private	signature:()
js::InlineMap::Range::checkInlineRangeInvariants	InlineMap.h	/^        bool checkInlineRangeInvariants() const {$/;"	f	class:js::InlineMap::Range	access:private	signature:() const
js::InlineMap::Range::cur	InlineMap.h	/^        InlineElem      *cur;$/;"	m	class:js::InlineMap::Range	access:private
js::InlineMap::Range::empty	InlineMap.h	/^        bool empty() const {$/;"	f	class:js::InlineMap::Range	access:public	signature:() const
js::InlineMap::Range::end	InlineMap.h	/^        InlineElem      *end;$/;"	m	class:js::InlineMap::Range	access:private
js::InlineMap::Range::front	InlineMap.h	/^        Entry front() {$/;"	f	class:js::InlineMap::Range	access:public	signature:()
js::InlineMap::Range::isInline	InlineMap.h	/^        bool            isInline;$/;"	m	class:js::InlineMap::Range	access:private
js::InlineMap::Range::isInlineRange	InlineMap.h	/^        bool isInlineRange() const {$/;"	f	class:js::InlineMap::Range	access:private	signature:() const
js::InlineMap::Range::mapRange	InlineMap.h	/^        WordMapRange    mapRange;$/;"	m	class:js::InlineMap::Range	access:private
js::InlineMap::Range::operator ==	InlineMap.h	/^        void operator==(const Range &other);$/;"	p	class:js::InlineMap::Range	access:private	signature:(const Range &other)
js::InlineMap::Range::popFront	InlineMap.h	/^        void popFront() {$/;"	f	class:js::InlineMap::Range	access:public	signature:()
js::InlineMap::WordMap	InlineMap.h	/^    typedef HashMap<K, V, DefaultHasher<K>, SystemAllocPolicy> WordMap;$/;"	t	class:js::InlineMap	access:public
js::InlineMap::WordMapAddPtr	InlineMap.h	/^    typedef typename WordMap::AddPtr    WordMapAddPtr;$/;"	t	class:js::InlineMap	access:private
js::InlineMap::WordMapPtr	InlineMap.h	/^    typedef typename WordMap::Ptr       WordMapPtr;$/;"	t	class:js::InlineMap	access:private
js::InlineMap::WordMapRange	InlineMap.h	/^    typedef typename WordMap::Range     WordMapRange;$/;"	t	class:js::InlineMap	access:private
js::InlineMap::add	InlineMap.h	/^    bool add(AddPtr &p, const K &key, const V &value) {$/;"	f	class:js::InlineMap	access:public	signature:(AddPtr &p, const K &key, const V &value)
js::InlineMap::all	InlineMap.h	/^    Range all() const {$/;"	f	class:js::InlineMap	access:public	signature:() const
js::InlineMap::asInline	InlineMap.h	/^    const InlineElem *asInline() const {$/;"	f	class:js::InlineMap	access:public	signature:() const
js::InlineMap::asMap	InlineMap.h	/^    const WordMap &asMap() const {$/;"	f	class:js::InlineMap	access:public	signature:() const
js::InlineMap::clear	InlineMap.h	/^    void clear() {$/;"	f	class:js::InlineMap	access:public	signature:()
js::InlineMap::count	InlineMap.h	/^    size_t count() {$/;"	f	class:js::InlineMap	access:public	signature:()
js::InlineMap::empty	InlineMap.h	/^    bool empty() const {$/;"	f	class:js::InlineMap	access:public	signature:() const
js::InlineMap::inl	InlineMap.h	/^    InlineElem      inl[InlineElems];$/;"	m	class:js::InlineMap	access:private
js::InlineMap::inlCount	InlineMap.h	/^    size_t          inlCount;$/;"	m	class:js::InlineMap	access:private
js::InlineMap::inlNext	InlineMap.h	/^    size_t          inlNext;$/;"	m	class:js::InlineMap	access:private
js::InlineMap::inlineEnd	InlineMap.h	/^    const InlineElem *inlineEnd() const {$/;"	f	class:js::InlineMap	access:public	signature:() const
js::InlineMap::isMap	InlineMap.h	/^    bool isMap() const {$/;"	f	class:js::InlineMap	access:public	signature:() const
js::InlineMap::lookup	InlineMap.h	/^    Ptr lookup(const K &key) {$/;"	f	class:js::InlineMap	access:public	signature:(const K &key)
js::InlineMap::lookupForAdd	InlineMap.h	/^    AddPtr lookupForAdd(const K &key) {$/;"	f	class:js::InlineMap	access:public	signature:(const K &key)
js::InlineMap::map	InlineMap.h	/^    WordMap         map;$/;"	m	class:js::InlineMap	access:private
js::InlineMap::put	InlineMap.h	/^    bool put(const K &key, const V &value) {$/;"	f	class:js::InlineMap	access:public	signature:(const K &key, const V &value)
js::InlineMap::remove	InlineMap.h	/^    void remove(Ptr p) {$/;"	f	class:js::InlineMap	access:public	signature:(Ptr p)
js::InlineMap::remove	InlineMap.h	/^    void remove(const K &key) {$/;"	f	class:js::InlineMap	access:public	signature:(const K &key)
js::InlineMap::static_assert	InlineMap.h	/^    static_assert(ZeroIsReserved<K>::result,$/;"	p	class:js::InlineMap	access:private	signature:(ZeroIsReserved<K>::result, Ó)
js::InlineMap::switchAndAdd	InlineMap.h	/^    bool switchAndAdd(const K &key, const V &value) {$/;"	f	class:js::InlineMap	access:private	signature:(const K &key, const V &value)
js::InlineMap::switchToMap	InlineMap.h	/^    bool switchToMap() {$/;"	f	class:js::InlineMap	access:private	signature:()
js::InlineMap::usingMap	InlineMap.h	/^    bool usingMap() const {$/;"	f	class:js::InlineMap	access:private	signature:() const
js::LifoAlloc	LifoAlloc.h	/^class LifoAlloc$/;"	c	namespace:js
js::LifoAlloc::BumpChunk	LifoAlloc.h	/^    typedef detail::BumpChunk BumpChunk;$/;"	t	class:js::LifoAlloc	access:private
js::LifoAlloc::Enum	LifoAlloc.h	/^    class Enum$/;"	c	class:js::LifoAlloc	access:public
js::LifoAlloc::Enum::Enum	LifoAlloc.h	/^        explicit Enum(LifoAlloc &alloc)$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:(LifoAlloc &alloc)
js::LifoAlloc::Enum::alloc_	LifoAlloc.h	/^        LifoAlloc *alloc_;  \/\/ The LifoAlloc being traversed.$/;"	m	class:js::LifoAlloc::Enum	access:private
js::LifoAlloc::Enum::chunk_	LifoAlloc.h	/^        BumpChunk *chunk_;  \/\/ The current chunk.$/;"	m	class:js::LifoAlloc::Enum	access:private
js::LifoAlloc::Enum::empty	LifoAlloc.h	/^        bool empty() {$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:()
js::LifoAlloc::Enum::ensureSpaceAndAlignment	LifoAlloc.h	/^        void ensureSpaceAndAlignment(size_t size) {$/;"	f	class:js::LifoAlloc::Enum	access:private	signature:(size_t size)
js::LifoAlloc::Enum::get	LifoAlloc.h	/^        T *get(size_t size = sizeof(T)) {$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:(size_t size = sizeof(T))
js::LifoAlloc::Enum::mark	LifoAlloc.h	/^        Mark mark() {$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:()
js::LifoAlloc::Enum::popFront	LifoAlloc.h	/^        void popFront() {$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:()
js::LifoAlloc::Enum::popFront	LifoAlloc.h	/^        void popFront(size_t size) {$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:(size_t size)
js::LifoAlloc::Enum::position_	LifoAlloc.h	/^        char *position_;    \/\/ The current position (must be within chunk_).$/;"	m	class:js::LifoAlloc::Enum	access:private
js::LifoAlloc::Enum::updateFront	LifoAlloc.h	/^        void updateFront(const T &t) {$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:(const T &t)
js::LifoAlloc::HUGE_ALLOCATION	LifoAlloc.h	/^    static const unsigned HUGE_ALLOCATION = 50 * 1024 * 1024;$/;"	m	class:js::LifoAlloc	access:public
js::LifoAlloc::LifoAlloc	LifoAlloc.h	/^    explicit LifoAlloc(size_t defaultChunkSize)$/;"	f	class:js::LifoAlloc	access:public	signature:(size_t defaultChunkSize)
js::LifoAlloc::MOZ_DELETE	LifoAlloc.h	/^    LifoAlloc(const LifoAlloc &) MOZ_DELETE;$/;"	m	class:js::LifoAlloc	access:private
js::LifoAlloc::MOZ_DELETE	LifoAlloc.h	/^    void operator=(const LifoAlloc &) MOZ_DELETE;$/;"	m	class:js::LifoAlloc	access:private
js::LifoAlloc::Mark	LifoAlloc.h	/^    class Mark {$/;"	c	class:js::LifoAlloc	access:public
js::LifoAlloc::Mark::Mark	LifoAlloc.h	/^        Mark() : chunk(nullptr), markInChunk(nullptr) {}$/;"	f	class:js::LifoAlloc::Mark	access:public	signature:()
js::LifoAlloc::Mark::Mark	LifoAlloc.h	/^        Mark(BumpChunk *chunk, void *markInChunk) : chunk(chunk), markInChunk(markInChunk) {}$/;"	f	class:js::LifoAlloc::Mark	access:private	signature:(BumpChunk *chunk, void *markInChunk)
js::LifoAlloc::Mark::chunk	LifoAlloc.h	/^        BumpChunk *chunk;$/;"	m	class:js::LifoAlloc::Mark	access:private
js::LifoAlloc::Mark::markInChunk	LifoAlloc.h	/^        void *markInChunk;$/;"	m	class:js::LifoAlloc::Mark	access:private
js::LifoAlloc::alloc	LifoAlloc.h	/^    void *alloc(size_t n) {$/;"	f	class:js::LifoAlloc	access:public	signature:(size_t n)
js::LifoAlloc::allocInfallible	LifoAlloc.h	/^    void *allocInfallible(size_t n) {$/;"	f	class:js::LifoAlloc	access:public	signature:(size_t n)
js::LifoAlloc::appendUnused	LifoAlloc.h	/^    void appendUnused(BumpChunk *start, BumpChunk *end) {$/;"	f	class:js::LifoAlloc	access:private	signature:(BumpChunk *start, BumpChunk *end)
js::LifoAlloc::appendUsed	LifoAlloc.h	/^    void appendUsed(BumpChunk *start, BumpChunk *latest, BumpChunk *end) {$/;"	f	class:js::LifoAlloc	access:private	signature:(BumpChunk *start, BumpChunk *latest, BumpChunk *end)
js::LifoAlloc::availableInCurrentChunk	LifoAlloc.h	/^    size_t availableInCurrentChunk() const {$/;"	f	class:js::LifoAlloc	access:public	signature:() const
js::LifoAlloc::computedSizeOfExcludingThis	LifoAlloc.h	/^    size_t computedSizeOfExcludingThis() const {$/;"	f	class:js::LifoAlloc	access:public	signature:() const
js::LifoAlloc::curSize_	LifoAlloc.h	/^    size_t      curSize_;$/;"	m	class:js::LifoAlloc	access:private
js::LifoAlloc::decrementCurSize	LifoAlloc.h	/^    void decrementCurSize(size_t size) {$/;"	f	class:js::LifoAlloc	access:private	signature:(size_t size)
js::LifoAlloc::defaultChunkSize	LifoAlloc.h	/^    size_t defaultChunkSize() const { return defaultChunkSize_; }$/;"	f	class:js::LifoAlloc	access:public	signature:() const
js::LifoAlloc::defaultChunkSize_	LifoAlloc.h	/^    size_t      defaultChunkSize_;$/;"	m	class:js::LifoAlloc	access:private
js::LifoAlloc::ensureUnusedApproximate	LifoAlloc.h	/^    bool ensureUnusedApproximate(size_t n) {$/;"	f	class:js::LifoAlloc	access:public	signature:(size_t n)
js::LifoAlloc::first	LifoAlloc.h	/^    BumpChunk   *first;$/;"	m	class:js::LifoAlloc	access:private
js::LifoAlloc::freeAll	LifoAlloc.h	/^    void freeAll();$/;"	p	class:js::LifoAlloc	access:public	signature:()
js::LifoAlloc::freeAllIfHugeAndUnused	LifoAlloc.h	/^    void freeAllIfHugeAndUnused() {$/;"	f	class:js::LifoAlloc	access:public	signature:()
js::LifoAlloc::getOrCreateChunk	LifoAlloc.h	/^    BumpChunk *getOrCreateChunk(size_t n);$/;"	p	class:js::LifoAlloc	access:private	signature:(size_t n)
js::LifoAlloc::incrementCurSize	LifoAlloc.h	/^    void incrementCurSize(size_t size) {$/;"	f	class:js::LifoAlloc	access:private	signature:(size_t size)
js::LifoAlloc::isEmpty	LifoAlloc.h	/^    bool isEmpty() const {$/;"	f	class:js::LifoAlloc	access:public	signature:() const
js::LifoAlloc::last	LifoAlloc.h	/^    BumpChunk   *last;$/;"	m	class:js::LifoAlloc	access:private
js::LifoAlloc::latest	LifoAlloc.h	/^    BumpChunk   *latest;$/;"	m	class:js::LifoAlloc	access:private
js::LifoAlloc::mark	LifoAlloc.h	/^    Mark mark() {$/;"	f	class:js::LifoAlloc	access:public	signature:()
js::LifoAlloc::markCount	LifoAlloc.h	/^    size_t      markCount;$/;"	m	class:js::LifoAlloc	access:private
js::LifoAlloc::newArray	LifoAlloc.h	/^    T *newArray(size_t count) {$/;"	f	class:js::LifoAlloc	access:public	signature:(size_t count)
js::LifoAlloc::newArrayUninitialized	LifoAlloc.h	/^    T *newArrayUninitialized(size_t count) {$/;"	f	class:js::LifoAlloc	access:public	signature:(size_t count)
js::LifoAlloc::peakSizeOfExcludingThis	LifoAlloc.h	/^    size_t peakSizeOfExcludingThis() const { return peakSize_; }$/;"	f	class:js::LifoAlloc	access:public	signature:() const
js::LifoAlloc::peakSize_	LifoAlloc.h	/^    size_t      peakSize_;$/;"	m	class:js::LifoAlloc	access:private
js::LifoAlloc::pod_malloc	LifoAlloc.h	/^    T *pod_malloc() {$/;"	f	class:js::LifoAlloc	access:public	signature:()
js::LifoAlloc::release	LifoAlloc.h	/^    void release(Mark mark) {$/;"	f	class:js::LifoAlloc	access:public	signature:(Mark mark)
js::LifoAlloc::releaseAll	LifoAlloc.h	/^    void releaseAll() {$/;"	f	class:js::LifoAlloc	access:public	signature:()
js::LifoAlloc::reset	LifoAlloc.h	/^    void reset(size_t defaultChunkSize) {$/;"	f	class:js::LifoAlloc	access:private	signature:(size_t defaultChunkSize)
js::LifoAlloc::sizeOfExcludingThis	LifoAlloc.h	/^    size_t sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const {$/;"	f	class:js::LifoAlloc	access:public	signature:(mozilla::MallocSizeOf mallocSizeOf) const
js::LifoAlloc::sizeOfIncludingThis	LifoAlloc.h	/^    size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const {$/;"	f	class:js::LifoAlloc	access:public	signature:(mozilla::MallocSizeOf mallocSizeOf) const
js::LifoAlloc::steal	LifoAlloc.h	/^    void steal(LifoAlloc *other) {$/;"	f	class:js::LifoAlloc	access:public	signature:(LifoAlloc *other)
js::LifoAlloc::transferFrom	LifoAlloc.h	/^    void transferFrom(LifoAlloc *other);$/;"	p	class:js::LifoAlloc	access:public	signature:(LifoAlloc *other)
js::LifoAlloc::transferUnusedFrom	LifoAlloc.h	/^    void transferUnusedFrom(LifoAlloc *other);$/;"	p	class:js::LifoAlloc	access:public	signature:(LifoAlloc *other)
js::LifoAlloc::used	LifoAlloc.h	/^    size_t used() const {$/;"	f	class:js::LifoAlloc	access:public	signature:() const
js::LifoAlloc::~LifoAlloc	LifoAlloc.h	/^    ~LifoAlloc() { freeAll(); }$/;"	f	class:js::LifoAlloc	access:public	signature:()
js::LifoAllocPolicy	LifoAlloc.h	/^class LifoAllocPolicy$/;"	c	namespace:js
js::LifoAllocPolicy::LifoAllocPolicy	LifoAlloc.h	/^    MOZ_IMPLICIT LifoAllocPolicy(LifoAlloc &alloc)$/;"	f	class:js::LifoAllocPolicy	access:public	signature:(LifoAlloc &alloc)
js::LifoAllocPolicy::alloc_	LifoAlloc.h	/^    LifoAlloc &alloc_;$/;"	m	class:js::LifoAllocPolicy	access:private
js::LifoAllocPolicy::free_	LifoAlloc.h	/^    void free_(void *p) {$/;"	f	class:js::LifoAllocPolicy	access:public	signature:(void *p)
js::LifoAllocPolicy::pod_calloc	LifoAlloc.h	/^    T *pod_calloc(size_t numElems) {$/;"	f	class:js::LifoAllocPolicy	access:public	signature:(size_t numElems)
js::LifoAllocPolicy::pod_malloc	LifoAlloc.h	/^    T *pod_malloc(size_t numElems) {$/;"	f	class:js::LifoAllocPolicy	access:public	signature:(size_t numElems)
js::LifoAllocPolicy::pod_realloc	LifoAlloc.h	/^    T *pod_realloc(T *p, size_t oldSize, size_t newSize) {$/;"	f	class:js::LifoAllocPolicy	access:public	signature:(T *p, size_t oldSize, size_t newSize)
js::LifoAllocPolicy::reportAllocOverflow	LifoAlloc.h	/^    void reportAllocOverflow() const {$/;"	f	class:js::LifoAllocPolicy	access:public	signature:() const
js::LifoAllocScope	LifoAlloc.h	/^class LifoAllocScope$/;"	c	namespace:js
js::LifoAllocScope::LifoAllocScope	LifoAlloc.h	/^    explicit LifoAllocScope(LifoAlloc *lifoAlloc$/;"	f	class:js::LifoAllocScope	access:public	signature:(LifoAlloc *lifoAlloc MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
js::LifoAllocScope::alloc	LifoAlloc.h	/^    LifoAlloc &alloc() {$/;"	f	class:js::LifoAllocScope	access:public	signature:()
js::LifoAllocScope::lifoAlloc	LifoAlloc.h	/^    LifoAlloc       *lifoAlloc;$/;"	m	class:js::LifoAllocScope	access:private
js::LifoAllocScope::mark	LifoAlloc.h	/^    LifoAlloc::Mark mark;$/;"	m	class:js::LifoAllocScope	access:private
js::LifoAllocScope::releaseEarly	LifoAlloc.h	/^    void releaseEarly() {$/;"	f	class:js::LifoAllocScope	access:public	signature:()
js::LifoAllocScope::shouldRelease	LifoAlloc.h	/^    bool            shouldRelease;$/;"	m	class:js::LifoAllocScope	access:private
js::LifoAllocScope::~LifoAllocScope	LifoAlloc.h	/^    ~LifoAllocScope() {$/;"	f	class:js::LifoAllocScope	access:public	signature:()
js::MergeSort	Sort.h	/^MergeSort(T *array, size_t nelems, T *scratch, Comparator c)$/;"	f	namespace:js	signature:(T *array, size_t nelems, T *scratch, Comparator c)
js::PriorityQueue	PriorityQueue.h	/^class PriorityQueue$/;"	c	namespace:js
js::PriorityQueue::MOZ_DELETE	PriorityQueue.h	/^    PriorityQueue &operator=(const PriorityQueue &) MOZ_DELETE;$/;"	m	class:js::PriorityQueue	access:private
js::PriorityQueue::MOZ_DELETE	PriorityQueue.h	/^    PriorityQueue(const PriorityQueue &) MOZ_DELETE;$/;"	m	class:js::PriorityQueue	access:private
js::PriorityQueue::PriorityQueue	PriorityQueue.h	/^    explicit PriorityQueue(AllocPolicy ap = AllocPolicy())$/;"	f	class:js::PriorityQueue	access:public	signature:(AllocPolicy ap = AllocPolicy())
js::PriorityQueue::empty	PriorityQueue.h	/^    bool empty() const {$/;"	f	class:js::PriorityQueue	access:public	signature:() const
js::PriorityQueue::heap	PriorityQueue.h	/^    Vector<T, MinInlineCapacity, AllocPolicy> heap;$/;"	m	class:js::PriorityQueue	access:private
js::PriorityQueue::infallibleInsert	PriorityQueue.h	/^    void infallibleInsert(const T &v) {$/;"	f	class:js::PriorityQueue	access:public	signature:(const T &v)
js::PriorityQueue::insert	PriorityQueue.h	/^    bool insert(const T &v) {$/;"	f	class:js::PriorityQueue	access:public	signature:(const T &v)
js::PriorityQueue::length	PriorityQueue.h	/^    size_t length() const {$/;"	f	class:js::PriorityQueue	access:public	signature:() const
js::PriorityQueue::removeHighest	PriorityQueue.h	/^    T removeHighest() {$/;"	f	class:js::PriorityQueue	access:public	signature:()
js::PriorityQueue::reserve	PriorityQueue.h	/^    bool reserve(size_t capacity) {$/;"	f	class:js::PriorityQueue	access:public	signature:(size_t capacity)
js::PriorityQueue::siftDown	PriorityQueue.h	/^    void siftDown(size_t n) {$/;"	f	class:js::PriorityQueue	access:private	signature:(size_t n)
js::PriorityQueue::siftUp	PriorityQueue.h	/^    void siftUp(size_t n) {$/;"	f	class:js::PriorityQueue	access:private	signature:(size_t n)
js::PriorityQueue::swap	PriorityQueue.h	/^    void swap(size_t a, size_t b) {$/;"	f	class:js::PriorityQueue	access:private	signature:(size_t a, size_t b)
js::SplayTree	SplayTree.h	/^class SplayTree$/;"	c	namespace:js
js::SplayTree::MOZ_DELETE	SplayTree.h	/^    SplayTree &operator=(const SplayTree &) MOZ_DELETE;$/;"	m	class:js::SplayTree	access:private
js::SplayTree::MOZ_DELETE	SplayTree.h	/^    SplayTree(const SplayTree &) MOZ_DELETE;$/;"	m	class:js::SplayTree	access:private
js::SplayTree::Node	SplayTree.h	/^    struct Node {$/;"	s	class:js::SplayTree	access:private
js::SplayTree::Node::Node	SplayTree.h	/^        explicit Node(const T &item)$/;"	f	struct:js::SplayTree::Node	access:public	signature:(const T &item)
js::SplayTree::Node::item	SplayTree.h	/^        T item;$/;"	m	struct:js::SplayTree::Node	access:public
js::SplayTree::Node::left	SplayTree.h	/^        Node *left, *right, *parent;$/;"	m	struct:js::SplayTree::Node	access:public
js::SplayTree::Node::parent	SplayTree.h	/^        Node *left, *right, *parent;$/;"	m	struct:js::SplayTree::Node	access:public
js::SplayTree::Node::right	SplayTree.h	/^        Node *left, *right, *parent;$/;"	m	struct:js::SplayTree::Node	access:public
js::SplayTree::SplayTree	SplayTree.h	/^    explicit SplayTree(LifoAlloc *alloc = nullptr)$/;"	f	class:js::SplayTree	access:public	signature:(LifoAlloc *alloc = nullptr)
js::SplayTree::alloc	SplayTree.h	/^    LifoAlloc *alloc;$/;"	m	class:js::SplayTree	access:private
js::SplayTree::allocateNode	SplayTree.h	/^    Node *allocateNode(const T &v)$/;"	f	class:js::SplayTree	access:private	signature:(const T &v)
js::SplayTree::checkCoherency	SplayTree.h	/^    Node *checkCoherency(Node *node, Node *minimum)$/;"	f	class:js::SplayTree	access:private	signature:(Node *node, Node *minimum)
js::SplayTree::contains	SplayTree.h	/^    bool contains(const T &v, T *res)$/;"	f	class:js::SplayTree	access:public	signature:(const T &v, T *res)
js::SplayTree::disableCheckCoherency	SplayTree.h	/^    void disableCheckCoherency() {$/;"	f	class:js::SplayTree	access:public	signature:()
js::SplayTree::empty	SplayTree.h	/^    bool empty() const {$/;"	f	class:js::SplayTree	access:public	signature:() const
js::SplayTree::enableCheckCoherency	SplayTree.h	/^    bool enableCheckCoherency;$/;"	m	class:js::SplayTree	access:private
js::SplayTree::forEach	SplayTree.h	/^    void forEach(Op op)$/;"	f	class:js::SplayTree	access:public	signature:(Op op)
js::SplayTree::forEachInner	SplayTree.h	/^    void forEachInner(Op op, Node *node)$/;"	f	class:js::SplayTree	access:private	signature:(Op op, Node *node)
js::SplayTree::freeList	SplayTree.h	/^    Node *root, *freeList;$/;"	m	class:js::SplayTree	access:private
js::SplayTree::freeNode	SplayTree.h	/^    void freeNode(Node *node)$/;"	f	class:js::SplayTree	access:private	signature:(Node *node)
js::SplayTree::insert	SplayTree.h	/^    bool insert(const T &v)$/;"	f	class:js::SplayTree	access:public	signature:(const T &v)
js::SplayTree::lookup	SplayTree.h	/^    Node *lookup(const T &v)$/;"	f	class:js::SplayTree	access:private	signature:(const T &v)
js::SplayTree::remove	SplayTree.h	/^    void remove(const T &v)$/;"	f	class:js::SplayTree	access:public	signature:(const T &v)
js::SplayTree::root	SplayTree.h	/^    Node *root, *freeList;$/;"	m	class:js::SplayTree	access:private
js::SplayTree::rotate	SplayTree.h	/^    void rotate(Node *node)$/;"	f	class:js::SplayTree	access:private	signature:(Node *node)
js::SplayTree::setAllocator	SplayTree.h	/^    void setAllocator(LifoAlloc *alloc) {$/;"	f	class:js::SplayTree	access:public	signature:(LifoAlloc *alloc)
js::SplayTree::splay	SplayTree.h	/^    void splay(Node *node)$/;"	f	class:js::SplayTree	access:private	signature:(Node *node)
js::ZeroIsReserved	InlineMap.h	/^template <typename T> struct ZeroIsReserved         { static const bool result = false; };$/;"	s	namespace:js
js::ZeroIsReserved	InlineMap.h	/^template <typename T> struct ZeroIsReserved<T *>    { static const bool result = true; };$/;"	s	namespace:js
js::ZeroIsReserved::result	InlineMap.h	/^template <typename T> struct ZeroIsReserved         { static const bool result = false; };$/;"	m	struct:js::ZeroIsReserved	access:public
js::ZeroIsReserved::result	InlineMap.h	/^template <typename T> struct ZeroIsReserved<T *>    { static const bool result = true; };$/;"	m	struct:js::ZeroIsReserved	access:public
js::detail	LifoAlloc.cpp	/^namespace detail {$/;"	n	namespace:js	file:
js::detail	LifoAlloc.h	/^namespace detail {$/;"	n	namespace:js
js::detail	Sort.h	/^namespace detail {$/;"	n	namespace:js
js::detail::AlignPtr	LifoAlloc.h	/^AlignPtr(void *orig)$/;"	f	namespace:js::detail	signature:(void *orig)
js::detail::BumpChunk	LifoAlloc.h	/^class BumpChunk$/;"	c	namespace:js::detail
js::detail::BumpChunk::BumpChunk	LifoAlloc.h	/^    explicit BumpChunk(size_t bumpSpaceSize)$/;"	f	class:js::detail::BumpChunk	access:private	signature:(size_t bumpSpaceSize)
js::detail::BumpChunk::bump	LifoAlloc.h	/^    char        *bump;          \/\/ start of the available data$/;"	m	class:js::detail::BumpChunk	access:private
js::detail::BumpChunk::bumpBase	LifoAlloc.h	/^    char *bumpBase() const { return limit - bumpSpaceSize; }$/;"	f	class:js::detail::BumpChunk	access:private	signature:() const
js::detail::BumpChunk::bumpSpaceSize	LifoAlloc.h	/^    size_t      bumpSpaceSize;  \/\/ size of the data area$/;"	m	class:js::detail::BumpChunk	access:private
js::detail::BumpChunk::canAlloc	LifoAlloc.cpp	/^BumpChunk::canAlloc(size_t n)$/;"	f	class:js::detail::BumpChunk	signature:(size_t n)
js::detail::BumpChunk::canAlloc	LifoAlloc.h	/^    bool canAlloc(size_t n);$/;"	p	class:js::detail::BumpChunk	access:public	signature:(size_t n)
js::detail::BumpChunk::computedSizeOfIncludingThis	LifoAlloc.h	/^    size_t computedSizeOfIncludingThis() {$/;"	f	class:js::detail::BumpChunk	access:public	signature:()
js::detail::BumpChunk::contains	LifoAlloc.h	/^    bool contains(void *mark) const {$/;"	f	class:js::detail::BumpChunk	access:public	signature:(void *mark) const
js::detail::BumpChunk::delete_	LifoAlloc.cpp	/^BumpChunk::delete_(BumpChunk *chunk)$/;"	f	class:js::detail::BumpChunk	signature:(BumpChunk *chunk)
js::detail::BumpChunk::delete_	LifoAlloc.h	/^    static void delete_(BumpChunk *chunk);$/;"	p	class:js::detail::BumpChunk	access:public	signature:(BumpChunk *chunk)
js::detail::BumpChunk::end	LifoAlloc.h	/^    void *end() const { return limit; }$/;"	f	class:js::detail::BumpChunk	access:public	signature:() const
js::detail::BumpChunk::headerBase	LifoAlloc.h	/^    char *headerBase() { return reinterpret_cast<char *>(this); }$/;"	f	class:js::detail::BumpChunk	access:private	signature:()
js::detail::BumpChunk::limit	LifoAlloc.h	/^    char        *limit;         \/\/ end of the data$/;"	m	class:js::detail::BumpChunk	access:private
js::detail::BumpChunk::mark	LifoAlloc.h	/^    void *mark() const { return bump; }$/;"	f	class:js::detail::BumpChunk	access:public	signature:() const
js::detail::BumpChunk::new_	LifoAlloc.cpp	/^BumpChunk::new_(size_t chunkSize)$/;"	f	class:js::detail::BumpChunk	signature:(size_t chunkSize)
js::detail::BumpChunk::new_	LifoAlloc.h	/^    static BumpChunk *new_(size_t chunkSize);$/;"	p	class:js::detail::BumpChunk	access:public	signature:(size_t chunkSize)
js::detail::BumpChunk::next	LifoAlloc.h	/^    BumpChunk *next() const { return next_; }$/;"	f	class:js::detail::BumpChunk	access:public	signature:() const
js::detail::BumpChunk::next_	LifoAlloc.h	/^    BumpChunk   *next_;         \/\/ the next BumpChunk$/;"	m	class:js::detail::BumpChunk	access:private
js::detail::BumpChunk::release	LifoAlloc.h	/^    void release(void *mark) {$/;"	f	class:js::detail::BumpChunk	access:public	signature:(void *mark)
js::detail::BumpChunk::resetBump	LifoAlloc.h	/^    void resetBump() {$/;"	f	class:js::detail::BumpChunk	access:public	signature:()
js::detail::BumpChunk::setBump	LifoAlloc.h	/^    void setBump(void *ptr) {$/;"	f	class:js::detail::BumpChunk	access:private	signature:(void *ptr)
js::detail::BumpChunk::setNext	LifoAlloc.h	/^    void setNext(BumpChunk *succ) { next_ = succ; }$/;"	f	class:js::detail::BumpChunk	access:public	signature:(BumpChunk *succ)
js::detail::BumpChunk::sizeOfIncludingThis	LifoAlloc.h	/^    size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) {$/;"	f	class:js::detail::BumpChunk	access:public	signature:(mozilla::MallocSizeOf mallocSizeOf)
js::detail::BumpChunk::start	LifoAlloc.h	/^    void *start() const { return bumpBase(); }$/;"	f	class:js::detail::BumpChunk	access:public	signature:() const
js::detail::BumpChunk::tryAlloc	LifoAlloc.h	/^    void *tryAlloc(size_t n) {$/;"	f	class:js::detail::BumpChunk	access:public	signature:(size_t n)
js::detail::BumpChunk::unused	LifoAlloc.h	/^    size_t unused() {$/;"	f	class:js::detail::BumpChunk	access:public	signature:()
js::detail::BumpChunk::used	LifoAlloc.h	/^    size_t used() const { return bump - bumpBase(); }$/;"	f	class:js::detail::BumpChunk	access:public	signature:() const
js::detail::CopyNonEmptyArray	Sort.h	/^CopyNonEmptyArray(T *dst, const T *src, size_t nelems)$/;"	f	namespace:js::detail	signature:(T *dst, const T *src, size_t nelems)
js::detail::LIFO_ALLOC_ALIGN	LifoAlloc.h	/^static const size_t LIFO_ALLOC_ALIGN = 8;$/;"	m	namespace:js::detail
js::detail::MergeArrayRuns	Sort.h	/^MergeArrayRuns(T *dst, const T *src, size_t run1, size_t run2, Comparator c)$/;"	f	namespace:js::detail	signature:(T *dst, const T *src, size_t run1, size_t run2, Comparator c)
jsfixedsizehash_h_	FixedSizeHash.h	/^#define jsfixedsizehash_h_$/;"	d
key	InlineMap.h	/^        K &key() {$/;"	f	class:js::InlineMap::Ptr	access:public	signature:()
key	InlineMap.h	/^        K key;$/;"	m	struct:js::InlineMap::InlineElem	access:public
key	InlineMap.h	/^        const K &key() { return key_; }$/;"	f	class:js::InlineMap::Entry	access:public	signature:()
key_	InlineMap.h	/^        const K &key_;$/;"	m	class:js::InlineMap::Entry	access:private
last	LifoAlloc.h	/^    BumpChunk   *last;$/;"	m	class:js::LifoAlloc	access:private
lastOperations	FixedSizeHash.h	/^    uint32_t lastOperations[Capacity];$/;"	m	class:js::FixedSizeHashSet	access:private
latest	LifoAlloc.h	/^    BumpChunk   *latest;$/;"	m	class:js::LifoAlloc	access:private
left	SplayTree.h	/^        Node *left, *right, *parent;$/;"	m	struct:js::SplayTree::Node	access:public
length	PriorityQueue.h	/^    size_t length() const {$/;"	f	class:js::PriorityQueue	access:public	signature:() const
lifoAlloc	LifoAlloc.h	/^    LifoAlloc       *lifoAlloc;$/;"	m	class:js::LifoAllocScope	access:private
limit	LifoAlloc.h	/^    char        *limit;         \/\/ end of the data$/;"	m	class:js::detail::BumpChunk	access:private
lookup	FixedSizeHash.h	/^    bool lookup(const Lookup &lookup, T *pentry)$/;"	f	class:js::FixedSizeHashSet	access:public	signature:(const Lookup &lookup, T *pentry)
lookup	InlineMap.h	/^    Ptr lookup(const K &key) {$/;"	f	class:js::InlineMap	access:public	signature:(const K &key)
lookup	SplayTree.h	/^    Node *lookup(const T &v)$/;"	f	class:js::SplayTree	access:private	signature:(const T &v)
lookupForAdd	InlineMap.h	/^    AddPtr lookupForAdd(const K &key) {$/;"	f	class:js::InlineMap	access:public	signature:(const K &key)
lookupReference	FixedSizeHash.h	/^    bool lookupReference(const S &s, size_t *pbucket)$/;"	f	class:js::FixedSizeHashSet	access:private	signature:(const S &s, size_t *pbucket)
map	InlineMap.h	/^    WordMap         map;$/;"	m	class:js::InlineMap	access:private
mapAddPtr	InlineMap.h	/^        WordMapAddPtr   mapAddPtr;$/;"	m	class:js::InlineMap::AddPtr	access:private
mapPtr	InlineMap.h	/^        WordMapPtr  mapPtr;$/;"	m	class:js::InlineMap::Ptr	access:private
mapRange	InlineMap.h	/^        WordMapRange    mapRange;$/;"	m	class:js::InlineMap::Range	access:private
mark	LifoAlloc.h	/^        Mark mark() {$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:()
mark	LifoAlloc.h	/^    LifoAlloc::Mark mark;$/;"	m	class:js::LifoAllocScope	access:private
mark	LifoAlloc.h	/^    Mark mark() {$/;"	f	class:js::LifoAlloc	access:public	signature:()
mark	LifoAlloc.h	/^    void *mark() const { return bump; }$/;"	f	class:js::detail::BumpChunk	access:public	signature:() const
markCount	LifoAlloc.h	/^    size_t      markCount;$/;"	m	class:js::LifoAlloc	access:private
markInChunk	LifoAlloc.h	/^        void *markInChunk;$/;"	m	class:js::LifoAlloc::Mark	access:private
newArray	LifoAlloc.h	/^    T *newArray(size_t count) {$/;"	f	class:js::LifoAlloc	access:public	signature:(size_t count)
newArrayUninitialized	LifoAlloc.h	/^    T *newArrayUninitialized(size_t count) {$/;"	f	class:js::LifoAlloc	access:public	signature:(size_t count)
new_	LifoAlloc.cpp	/^BumpChunk::new_(size_t chunkSize)$/;"	f	class:js::detail::BumpChunk	signature:(size_t chunkSize)
new_	LifoAlloc.h	/^    static BumpChunk *new_(size_t chunkSize);$/;"	p	class:js::detail::BumpChunk	access:public	signature:(size_t chunkSize)
next	LifoAlloc.h	/^    BumpChunk *next() const { return next_; }$/;"	f	class:js::detail::BumpChunk	access:public	signature:() const
next_	LifoAlloc.h	/^    BumpChunk   *next_;         \/\/ the next BumpChunk$/;"	m	class:js::detail::BumpChunk	access:private
numOperations	FixedSizeHash.h	/^    uint32_t numOperations;$/;"	m	class:js::FixedSizeHashSet	access:private
numSlots	BitArray.h	/^    static const size_t numSlots = nbits \/ bitsPerElement + (nbits % bitsPerElement == 0 ? 0 : 1);$/;"	m	class:js::BitArray	access:private
operator ==	InlineMap.h	/^        void operator==(const AddPtr &other);$/;"	p	class:js::InlineMap::AddPtr	access:private	signature:(const AddPtr &other)
operator ==	InlineMap.h	/^        void operator==(const Ptr &other);$/;"	p	class:js::InlineMap::Ptr	access:private	signature:(const Ptr &other)
operator ==	InlineMap.h	/^        void operator==(const Range &other);$/;"	p	class:js::InlineMap::Range	access:private	signature:(const Range &other)
operator ConvertibleToBool	InlineMap.h	/^        operator ConvertibleToBool() const {$/;"	f	class:js::InlineMap::AddPtr	access:public	signature:() const
operator ConvertibleToBool	InlineMap.h	/^        operator ConvertibleToBool() const {$/;"	f	class:js::InlineMap::Ptr	access:public	signature:() const
paddingBits	BitArray.h	/^    static const size_t paddingBits = (numSlots * bitsPerElement) - nbits;$/;"	m	class:js::BitArray	access:private
parent	SplayTree.h	/^        Node *left, *right, *parent;$/;"	m	struct:js::SplayTree::Node	access:public
peakSizeOfExcludingThis	LifoAlloc.h	/^    size_t peakSizeOfExcludingThis() const { return peakSize_; }$/;"	f	class:js::LifoAlloc	access:public	signature:() const
peakSize_	LifoAlloc.h	/^    size_t      peakSize_;$/;"	m	class:js::LifoAlloc	access:private
pod_calloc	LifoAlloc.h	/^    T *pod_calloc(size_t numElems) {$/;"	f	class:js::LifoAllocPolicy	access:public	signature:(size_t numElems)
pod_malloc	LifoAlloc.h	/^    T *pod_malloc() {$/;"	f	class:js::LifoAlloc	access:public	signature:()
pod_malloc	LifoAlloc.h	/^    T *pod_malloc(size_t numElems) {$/;"	f	class:js::LifoAllocPolicy	access:public	signature:(size_t numElems)
pod_realloc	LifoAlloc.h	/^    T *pod_realloc(T *p, size_t oldSize, size_t newSize) {$/;"	f	class:js::LifoAllocPolicy	access:public	signature:(T *p, size_t oldSize, size_t newSize)
popFront	InlineMap.h	/^        void popFront() {$/;"	f	class:js::InlineMap::Range	access:public	signature:()
popFront	LifoAlloc.h	/^        void popFront() {$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:()
popFront	LifoAlloc.h	/^        void popFront(size_t size) {$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:(size_t size)
position_	LifoAlloc.h	/^        char *position_;    \/\/ The current position (must be within chunk_).$/;"	m	class:js::LifoAlloc::Enum	access:private
put	InlineMap.h	/^    bool put(const K &key, const V &value) {$/;"	f	class:js::InlineMap	access:public	signature:(const K &key, const V &value)
release	LifoAlloc.h	/^    void release(Mark mark) {$/;"	f	class:js::LifoAlloc	access:public	signature:(Mark mark)
release	LifoAlloc.h	/^    void release(void *mark) {$/;"	f	class:js::detail::BumpChunk	access:public	signature:(void *mark)
releaseAll	LifoAlloc.h	/^    void releaseAll() {$/;"	f	class:js::LifoAlloc	access:public	signature:()
releaseEarly	LifoAlloc.h	/^    void releaseEarly() {$/;"	f	class:js::LifoAllocScope	access:public	signature:()
remove	FixedSizeHash.h	/^    void remove(const S &s)$/;"	f	class:js::FixedSizeHashSet	access:public	signature:(const S &s)
remove	InlineMap.h	/^    void remove(Ptr p) {$/;"	f	class:js::InlineMap	access:public	signature:(Ptr p)
remove	InlineMap.h	/^    void remove(const K &key) {$/;"	f	class:js::InlineMap	access:public	signature:(const K &key)
remove	SplayTree.h	/^    void remove(const T &v)$/;"	f	class:js::SplayTree	access:public	signature:(const T &v)
removeHighest	PriorityQueue.h	/^    T removeHighest() {$/;"	f	class:js::PriorityQueue	access:public	signature:()
reportAllocOverflow	LifoAlloc.h	/^    void reportAllocOverflow() const {$/;"	f	class:js::LifoAllocPolicy	access:public	signature:() const
reserve	PriorityQueue.h	/^    bool reserve(size_t capacity) {$/;"	f	class:js::PriorityQueue	access:public	signature:(size_t capacity)
reset	LifoAlloc.h	/^    void reset(size_t defaultChunkSize) {$/;"	f	class:js::LifoAlloc	access:private	signature:(size_t defaultChunkSize)
resetBump	LifoAlloc.h	/^    void resetBump() {$/;"	f	class:js::detail::BumpChunk	access:public	signature:()
result	InlineMap.h	/^template <typename T> struct ZeroIsReserved         { static const bool result = false; };$/;"	m	struct:js::ZeroIsReserved	access:public
result	InlineMap.h	/^template <typename T> struct ZeroIsReserved<T *>    { static const bool result = true; };$/;"	m	struct:js::ZeroIsReserved	access:public
right	SplayTree.h	/^        Node *left, *right, *parent;$/;"	m	struct:js::SplayTree::Node	access:public
root	SplayTree.h	/^    Node *root, *freeList;$/;"	m	class:js::SplayTree	access:private
rotate	SplayTree.h	/^    void rotate(Node *node)$/;"	f	class:js::SplayTree	access:private	signature:(Node *node)
setAllocator	SplayTree.h	/^    void setAllocator(LifoAlloc *alloc) {$/;"	f	class:js::SplayTree	access:public	signature:(LifoAlloc *alloc)
setBump	LifoAlloc.h	/^    void setBump(void *ptr) {$/;"	f	class:js::detail::BumpChunk	access:private	signature:(void *ptr)
setNext	LifoAlloc.h	/^    void setNext(BumpChunk *succ) { next_ = succ; }$/;"	f	class:js::detail::BumpChunk	access:public	signature:(BumpChunk *succ)
shouldRelease	LifoAlloc.h	/^    bool            shouldRelease;$/;"	m	class:js::LifoAllocScope	access:private
siftDown	PriorityQueue.h	/^    void siftDown(size_t n) {$/;"	f	class:js::PriorityQueue	access:private	signature:(size_t n)
siftUp	PriorityQueue.h	/^    void siftUp(size_t n) {$/;"	f	class:js::PriorityQueue	access:private	signature:(size_t n)
sizeOfExcludingThis	LifoAlloc.h	/^    size_t sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const {$/;"	f	class:js::LifoAlloc	access:public	signature:(mozilla::MallocSizeOf mallocSizeOf) const
sizeOfIncludingThis	LifoAlloc.h	/^    size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const {$/;"	f	class:js::LifoAlloc	access:public	signature:(mozilla::MallocSizeOf mallocSizeOf) const
sizeOfIncludingThis	LifoAlloc.h	/^    size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) {$/;"	f	class:js::detail::BumpChunk	access:public	signature:(mozilla::MallocSizeOf mallocSizeOf)
splay	SplayTree.h	/^    void splay(Node *node)$/;"	f	class:js::SplayTree	access:private	signature:(Node *node)
start	LifoAlloc.h	/^    void *start() const { return bumpBase(); }$/;"	f	class:js::detail::BumpChunk	access:public	signature:() const
static_assert	InlineMap.h	/^    static_assert(ZeroIsReserved<K>::result,$/;"	p	class:js::InlineMap	access:private	signature:(ZeroIsReserved<K>::result, Ó)
steal	LifoAlloc.h	/^    void steal(LifoAlloc *other) {$/;"	f	class:js::LifoAlloc	access:public	signature:(LifoAlloc *other)
swap	PriorityQueue.h	/^    void swap(size_t a, size_t b) {$/;"	f	class:js::PriorityQueue	access:private	signature:(size_t a, size_t b)
switchAndAdd	InlineMap.h	/^    bool switchAndAdd(const K &key, const V &value) {$/;"	f	class:js::InlineMap	access:private	signature:(const K &key, const V &value)
switchToMap	InlineMap.h	/^    bool switchToMap() {$/;"	f	class:js::InlineMap	access:private	signature:()
transferFrom	LifoAlloc.cpp	/^LifoAlloc::transferFrom(LifoAlloc *other)$/;"	f	class:LifoAlloc	signature:(LifoAlloc *other)
transferFrom	LifoAlloc.h	/^    void transferFrom(LifoAlloc *other);$/;"	p	class:js::LifoAlloc	access:public	signature:(LifoAlloc *other)
transferUnusedFrom	LifoAlloc.cpp	/^LifoAlloc::transferUnusedFrom(LifoAlloc *other)$/;"	f	class:LifoAlloc	signature:(LifoAlloc *other)
transferUnusedFrom	LifoAlloc.h	/^    void transferUnusedFrom(LifoAlloc *other);$/;"	p	class:js::LifoAlloc	access:public	signature:(LifoAlloc *other)
tryAlloc	LifoAlloc.h	/^    void *tryAlloc(size_t n) {$/;"	f	class:js::detail::BumpChunk	access:public	signature:(size_t n)
unused	LifoAlloc.h	/^    size_t unused() {$/;"	f	class:js::detail::BumpChunk	access:public	signature:()
updateFront	LifoAlloc.h	/^        void updateFront(const T &t) {$/;"	f	class:js::LifoAlloc::Enum	access:public	signature:(const T &t)
used	LifoAlloc.h	/^    size_t used() const { return bump - bumpBase(); }$/;"	f	class:js::detail::BumpChunk	access:public	signature:() const
used	LifoAlloc.h	/^    size_t used() const {$/;"	f	class:js::LifoAlloc	access:public	signature:() const
usingMap	InlineMap.h	/^    bool usingMap() const {$/;"	f	class:js::InlineMap	access:private	signature:() const
value	IdValuePair.h	/^    Value value;$/;"	m	struct:js::IdValuePair	access:public
value	InlineMap.h	/^        V &value() { return value_; }$/;"	f	class:js::InlineMap::Entry	access:public	signature:()
value	InlineMap.h	/^        V &value() {$/;"	f	class:js::InlineMap::AddPtr	access:public	signature:()
value	InlineMap.h	/^        V &value() {$/;"	f	class:js::InlineMap::Ptr	access:public	signature:()
value	InlineMap.h	/^        V value;$/;"	m	struct:js::InlineMap::InlineElem	access:public
value_	InlineMap.h	/^        V &value_;$/;"	m	class:js::InlineMap::Entry	access:private
~LifoAlloc	LifoAlloc.h	/^    ~LifoAlloc() { freeAll(); }$/;"	f	class:js::LifoAlloc	access:public	signature:()
~LifoAllocScope	LifoAlloc.h	/^    ~LifoAllocScope() {$/;"	f	class:js::LifoAllocScope	access:public	signature:()
